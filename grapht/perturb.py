# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/03_perturb.ipynb (unless otherwise specified).

__all__ = ['khop_edge_deletion', 'khop_rewire', 'rewire']

# Cell
from nbdev.showdoc import *
import networkx as nx
import numpy as np
import pandas as pd
from .graphtools import non_pendant_edges, has_isolated_nodes
from .sampling import khop_subgraph, sample_edges

# Cell
def khop_edge_deletion(G, k, r, max_iter=np.Inf):
    """Removes r edges which are in a k-hop neighbourhood of some node, the perturbed graph will not have isolated nodes.

    If k is None then the samples are taken uniformly.

    This operation is attempted `max_iter` times, if no solution is found then `None` is returned.

    Returns:
        solution: a perturbed graph
        edges: a list of edges which were removed
        node: the node which the k-hop neighbourhood was taken around
    """
    solution, iteration = None, 0
    while solution is None:
        iteration = iteration + 1
        if iteration == max_iter:
            return None
        subgraph, node = khop_subgraph(G, k) if k is not None else (G, None)
        if len(non_pendant_edges(subgraph)) < r:
            continue
        edges = sample_edges(subgraph, r, non_pendant=True)
        Gp = G.copy()
        Gp.remove_edges_from(edges)
        if not has_isolated_nodes(Gp):
            solution = Gp
    return solution, edges, node

# Cell
def khop_rewire(G, k, r, max_iter=np.Inf):
    """Rewire the graph in place where edges which are rewired are in a k-hop neighbourhood.

    A random k-hop neighbourhood is selected in G and r edges are rewired.

    If the graph contains an isolated node this procedure is repeated.

    If `max_iter` attempted do not give a graph without isolated nodes `None` is returned.

    Returns:
        solution (nx.Graph): the rewired graph
        rewire_info (pd.DataFrame): a dataframe describing which edges were added or removed
        node: The node from which the k-hop neighbourhood was taken around
    """
    solution, iteration = None, 0
    while solution is None:
        iteration = iteration + 1
        if iteration == max_iter:
            return None
        subgraph, node = khop_subgraph(G, k) if k is not None else (G, None)
        if len(subgraph.edges()) < r:
            continue
        edges = sample_edges(subgraph, r, non_pendant=False)
        Gp = G.copy()
        rewire_info = rewire(Gp, edges)
        if not has_isolated_nodes(Gp):
            solution = Gp
    return solution, rewire_info, node

def rewire(G, edges):
    """Rewires `edges` in `G` inplace and returns a dataframe with the edges which were added or removed.

    All edges are broken into stubs and then stubs are randomly joined together.

    Self loops are removed after the rewiring step.

    A dataframe is returned where each row is (u, v, 'add') or (u, v, 'remove').

    The dataframe will include entries (u, u, 'add') if self loops were added but these won't appear in the graph.
    """
    edges = np.array(edges)
    new_edges = np.reshape(np.random.permutation(edges.flatten()), (-1, 2))
    G.remove_edges_from(edges.tolist())
    G.add_edges_from(new_edges.tolist())
    G.remove_edges_from(nx.selfloop_edges(G))
    dfrem = pd.DataFrame(edges, columns = ['u', 'v'])
    dfrem['type'] = 'remove'
    dfadd = pd.DataFrame(new_edges, columns = ['u', 'v'])
    dfadd['type'] = 'add'
    return pd.concat([dfrem, dfadd], ignore_index=True)